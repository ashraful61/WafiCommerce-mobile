{"ast":null,"code":"var _jsxFileName = \"F:\\\\Aftab-at-Wafi\\\\Projects\\\\WafiCommerce-mobile\\\\WafiCommerce\\\\node_modules\\\\react-native-snap-carousel\\\\src\\\\carousel\\\\Carousel.js\";\nimport React, { Component } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport FlatList from \"react-native-web/dist/exports/FlatList\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { ViewPropTypes } from \"react-native-web/dist/index\";\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport { defaultScrollInterpolator, stackScrollInterpolator, tinderScrollInterpolator, defaultAnimatedStyles, shiftAnimatedStyles, stackAnimatedStyles, tinderAnimatedStyles } from '../utils/animations';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst IS_IOS = Platform.OS === 'ios';\nconst AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nconst AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\nconst IS_RTL = I18nManager.isRTL;\nexport default class Carousel extends Component {\n  static propTypes = {\n    data: PropTypes.array.isRequired,\n    renderItem: PropTypes.func.isRequired,\n    itemWidth: PropTypes.number,\n    itemHeight: PropTypes.number,\n    sliderWidth: PropTypes.number,\n    sliderHeight: PropTypes.number,\n    activeAnimationType: PropTypes.string,\n    activeAnimationOptions: PropTypes.object,\n    activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n    activeSlideOffset: PropTypes.number,\n    apparitionDelay: PropTypes.number,\n    autoplay: PropTypes.bool,\n    autoplayDelay: PropTypes.number,\n    autoplayInterval: PropTypes.number,\n    callbackOffsetMargin: PropTypes.number,\n    containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n    contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n    enableMomentum: PropTypes.bool,\n    enableSnap: PropTypes.bool,\n    firstItem: PropTypes.number,\n    hasParallaxImages: PropTypes.bool,\n    inactiveSlideOpacity: PropTypes.number,\n    inactiveSlideScale: PropTypes.number,\n    inactiveSlideShift: PropTypes.number,\n    layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n    layoutCardOffset: PropTypes.number,\n    lockScrollTimeoutDuration: PropTypes.number,\n    lockScrollWhileSnapping: PropTypes.bool,\n    loop: PropTypes.bool,\n    loopClonesPerSide: PropTypes.number,\n    scrollEnabled: PropTypes.bool,\n    scrollInterpolator: PropTypes.func,\n    slideInterpolatedStyle: PropTypes.func,\n    slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n    shouldOptimizeUpdates: PropTypes.bool,\n    swipeThreshold: PropTypes.number,\n    useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    vertical: PropTypes.bool,\n    onBeforeSnapToItem: PropTypes.func,\n    onSnapToItem: PropTypes.func\n  };\n  static defaultProps = {\n    activeAnimationType: 'timing',\n    activeAnimationOptions: null,\n    activeSlideAlignment: 'center',\n    activeSlideOffset: 20,\n    apparitionDelay: 0,\n    autoplay: false,\n    autoplayDelay: 1000,\n    autoplayInterval: 3000,\n    callbackOffsetMargin: 5,\n    containerCustomStyle: {},\n    contentContainerCustomStyle: {},\n    enableMomentum: false,\n    enableSnap: true,\n    firstItem: 0,\n    hasParallaxImages: false,\n    inactiveSlideOpacity: 0.7,\n    inactiveSlideScale: 0.9,\n    inactiveSlideShift: 0,\n    layout: 'default',\n    lockScrollTimeoutDuration: 1000,\n    lockScrollWhileSnapping: false,\n    loop: false,\n    loopClonesPerSide: 3,\n    scrollEnabled: true,\n    slideStyle: {},\n    shouldOptimizeUpdates: true,\n    swipeThreshold: 20,\n    useScrollView: !AnimatedFlatList,\n    vertical: false\n  };\n  constructor(props) {\n    super(props);\n    this.state = {\n      hideCarousel: true,\n      interpolators: []\n    };\n    const initialActiveItem = this._getFirstItem(props.firstItem);\n    this._activeItem = initialActiveItem;\n    this._previousActiveItem = initialActiveItem;\n    this._previousFirstItem = initialActiveItem;\n    this._previousItemsLength = initialActiveItem;\n    this._mounted = false;\n    this._positions = [];\n    this._currentContentOffset = 0;\n    this._canFireBeforeCallback = false;\n    this._canFireCallback = false;\n    this._scrollOffsetRef = null;\n    this._onScrollTriggered = true;\n    this._lastScrollDate = 0;\n    this._scrollEnabled = props.scrollEnabled !== false;\n    this._initPositionsAndInterpolators = this._initPositionsAndInterpolators.bind(this);\n    this._renderItem = this._renderItem.bind(this);\n    this._onSnap = this._onSnap.bind(this);\n    this._onLayout = this._onLayout.bind(this);\n    this._onScroll = this._onScroll.bind(this);\n    this._onScrollBeginDrag = props.enableSnap ? this._onScrollBeginDrag.bind(this) : undefined;\n    this._onScrollEnd = props.enableSnap || props.autoplay ? this._onScrollEnd.bind(this) : undefined;\n    this._onScrollEndDrag = !props.enableMomentum ? this._onScrollEndDrag.bind(this) : undefined;\n    this._onMomentumScrollEnd = props.enableMomentum ? this._onMomentumScrollEnd.bind(this) : undefined;\n    this._onTouchStart = this._onTouchStart.bind(this);\n    this._onTouchEnd = this._onTouchEnd.bind(this);\n    this._onTouchRelease = this._onTouchRelease.bind(this);\n    this._getKeyExtractor = this._getKeyExtractor.bind(this);\n    this._setScrollHandler(props);\n    this._ignoreNextMomentum = false;\n    if (!ViewPropTypes) {\n      console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n    }\n    if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n      console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n    }\n    if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n      console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n    }\n    if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n      console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n    }\n    if (props.customAnimationType || props.customAnimationOptions) {\n      console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n    }\n    if (props.onScrollViewScroll) {\n      console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n    }\n  }\n  componentDidMount() {\n    const {\n      apparitionDelay,\n      autoplay,\n      firstItem\n    } = this.props;\n    const _firstItem = this._getFirstItem(firstItem);\n    const apparitionCallback = () => {\n      this.setState({\n        hideCarousel: false\n      });\n      if (autoplay) {\n        this.startAutoplay();\n      }\n    };\n    this._mounted = true;\n    this._initPositionsAndInterpolators();\n    requestAnimationFrame(() => {\n      if (!this._mounted) {\n        return;\n      }\n      this._snapToItem(_firstItem, false, false, true, false);\n      this._hackActiveSlideAnimation(_firstItem, 'start', true);\n      if (apparitionDelay) {\n        this._apparitionTimeout = setTimeout(() => {\n          apparitionCallback();\n        }, apparitionDelay);\n      } else {\n        apparitionCallback();\n      }\n    });\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.shouldOptimizeUpdates === false) {\n      return true;\n    } else {\n      return shallowCompare(this, nextProps, nextState);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    const {\n      interpolators\n    } = this.state;\n    const {\n      firstItem,\n      itemHeight,\n      itemWidth,\n      scrollEnabled,\n      sliderHeight,\n      sliderWidth\n    } = this.props;\n    const itemsLength = this._getCustomDataLength(this.props);\n    if (!itemsLength) {\n      return;\n    }\n    const nextFirstItem = this._getFirstItem(firstItem, this.props);\n    let nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n    const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n    const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n    const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n    const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n    const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n    if (nextActiveItem > itemsLength - 1) {\n      nextActiveItem = itemsLength - 1;\n    }\n    if (hasNewScrollEnabled) {\n      this._setScrollEnabled(scrollEnabled);\n    }\n    if (interpolators.length !== itemsLength || hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n      this._activeItem = nextActiveItem;\n      this._previousItemsLength = itemsLength;\n      this._initPositionsAndInterpolators(this.props);\n      if (this._previousItemsLength > itemsLength) {\n        this._hackActiveSlideAnimation(nextActiveItem, null, true);\n      }\n      if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n        this._snapToItem(nextActiveItem, false, false, false, false);\n      }\n    } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n      this._activeItem = nextFirstItem;\n      this._previousFirstItem = nextFirstItem;\n      this._snapToItem(nextFirstItem, false, true, false, false);\n    }\n    if (this.props.onScroll !== prevProps.onScroll) {\n      this._setScrollHandler(this.props);\n    }\n  }\n  componentWillUnmount() {\n    this._mounted = false;\n    this.stopAutoplay();\n    clearTimeout(this._apparitionTimeout);\n    clearTimeout(this._hackSlideAnimationTimeout);\n    clearTimeout(this._enableAutoplayTimeout);\n    clearTimeout(this._autoplayTimeout);\n    clearTimeout(this._snapNoMomentumTimeout);\n    clearTimeout(this._edgeItemTimeout);\n    clearTimeout(this._lockScrollTimeout);\n  }\n  get realIndex() {\n    return this._activeItem;\n  }\n  get currentIndex() {\n    return this._getDataIndex(this._activeItem);\n  }\n  get currentScrollPosition() {\n    return this._currentContentOffset;\n  }\n  _setScrollHandler(props) {\n    const scrollEventConfig = {\n      listener: this._onScroll,\n      useNativeDriver: true\n    };\n    this._scrollPos = new Animated.Value(0);\n    const argMapping = props.vertical ? [{\n      nativeEvent: {\n        contentOffset: {\n          y: this._scrollPos\n        }\n      }\n    }] : [{\n      nativeEvent: {\n        contentOffset: {\n          x: this._scrollPos\n        }\n      }\n    }];\n    if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n      argMapping.pop();\n      const [argMap] = props.onScroll._argMapping;\n      if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n        this._scrollPos = argMap.nativeEvent.contentOffset.x || argMap.nativeEvent.contentOffset.y || this._scrollPos;\n      }\n      argMapping.push(...props.onScroll._argMapping);\n    }\n    this._onScrollHandler = Animated.event(argMapping, scrollEventConfig);\n  }\n  _needsScrollView() {\n    const {\n      useScrollView\n    } = this.props;\n    return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n  }\n  _needsRTLAdaptations() {\n    const {\n      vertical\n    } = this.props;\n    return IS_RTL && !IS_IOS && !vertical;\n  }\n  _canLockScroll() {\n    const {\n      scrollEnabled,\n      enableMomentum,\n      lockScrollWhileSnapping\n    } = this.props;\n    return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n  }\n  _enableLoop() {\n    const {\n      data,\n      enableSnap,\n      loop\n    } = this.props;\n    return enableSnap && loop && data && data.length && data.length > 1;\n  }\n  _shouldAnimateSlides(props = this.props) {\n    const {\n      inactiveSlideOpacity,\n      inactiveSlideScale,\n      scrollInterpolator,\n      slideInterpolatedStyle\n    } = props;\n    return inactiveSlideOpacity < 1 || inactiveSlideScale < 1 || !!scrollInterpolator || !!slideInterpolatedStyle || this._shouldUseShiftLayout() || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n  }\n  _shouldUseCustomAnimation() {\n    const {\n      activeAnimationOptions\n    } = this.props;\n    return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n  }\n  _shouldUseShiftLayout() {\n    const {\n      inactiveSlideShift,\n      layout\n    } = this.props;\n    return layout === 'default' && inactiveSlideShift !== 0;\n  }\n  _shouldUseStackLayout() {\n    return this.props.layout === 'stack';\n  }\n  _shouldUseTinderLayout() {\n    return this.props.layout === 'tinder';\n  }\n  _getCustomData(props = this.props) {\n    const {\n      data,\n      loopClonesPerSide\n    } = props;\n    const dataLength = data && data.length;\n    if (!dataLength) {\n      return [];\n    }\n    if (!this._enableLoop()) {\n      return data;\n    }\n    let previousItems = [];\n    let nextItems = [];\n    if (loopClonesPerSide > dataLength) {\n      const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n      const remainder = loopClonesPerSide % dataLength;\n      for (let i = 0; i < dataMultiplier; i++) {\n        previousItems.push(...data);\n        nextItems.push(...data);\n      }\n      previousItems.unshift(...data.slice(-remainder));\n      nextItems.push(...data.slice(0, remainder));\n    } else {\n      previousItems = data.slice(-loopClonesPerSide);\n      nextItems = data.slice(0, loopClonesPerSide);\n    }\n    return previousItems.concat(data, nextItems);\n  }\n  _getCustomDataLength(props = this.props) {\n    const {\n      data,\n      loopClonesPerSide\n    } = props;\n    const dataLength = data && data.length;\n    if (!dataLength) {\n      return 0;\n    }\n    return this._enableLoop() ? dataLength + 2 * loopClonesPerSide : dataLength;\n  }\n  _getCustomIndex(index, props = this.props) {\n    const itemsLength = this._getCustomDataLength(props);\n    if (!itemsLength || !index && index !== 0) {\n      return 0;\n    }\n    return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n  }\n  _getDataIndex(index) {\n    const {\n      data,\n      loopClonesPerSide\n    } = this.props;\n    const dataLength = data && data.length;\n    if (!this._enableLoop() || !dataLength) {\n      return index;\n    }\n    if (index >= dataLength + loopClonesPerSide) {\n      return loopClonesPerSide > dataLength ? (index - loopClonesPerSide) % dataLength : index - dataLength - loopClonesPerSide;\n    } else if (index < loopClonesPerSide) {\n      if (loopClonesPerSide > dataLength) {\n        const baseDataIndexes = [];\n        const dataIndexes = [];\n        const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n        const remainder = loopClonesPerSide % dataLength;\n        for (let i = 0; i < dataLength; i++) {\n          baseDataIndexes.push(i);\n        }\n        for (let j = 0; j < dataMultiplier; j++) {\n          dataIndexes.push(...baseDataIndexes);\n        }\n        dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n        return dataIndexes[index];\n      } else {\n        return index + dataLength - loopClonesPerSide;\n      }\n    } else {\n      return index - loopClonesPerSide;\n    }\n  }\n  _getPositionIndex(index) {\n    const {\n      loop,\n      loopClonesPerSide\n    } = this.props;\n    return loop ? index + loopClonesPerSide : index;\n  }\n  _getFirstItem(index, props = this.props) {\n    const {\n      loopClonesPerSide\n    } = props;\n    const itemsLength = this._getCustomDataLength(props);\n    if (!itemsLength || index > itemsLength - 1 || index < 0) {\n      return 0;\n    }\n    return this._enableLoop() ? index + loopClonesPerSide : index;\n  }\n  _getWrappedRef() {\n    if (this._carouselRef && (this._needsScrollView() && this._carouselRef.scrollTo || !this._needsScrollView() && this._carouselRef.scrollToOffset)) {\n      return this._carouselRef;\n    }\n    return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n  }\n  _getScrollEnabled() {\n    return this._scrollEnabled;\n  }\n  _setScrollEnabled(scrollEnabled = true) {\n    const wrappedRef = this._getWrappedRef();\n    if (!wrappedRef || !wrappedRef.setNativeProps) {\n      return;\n    }\n    wrappedRef.setNativeProps({\n      scrollEnabled\n    });\n    this._scrollEnabled = scrollEnabled;\n  }\n  _getKeyExtractor(item, index) {\n    return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;\n  }\n  _getScrollOffset(event) {\n    const {\n      vertical\n    } = this.props;\n    return event && event.nativeEvent && event.nativeEvent.contentOffset && event.nativeEvent.contentOffset[vertical ? 'y' : 'x'] || 0;\n  }\n  _getContainerInnerMargin(opposite = false) {\n    const {\n      sliderWidth,\n      sliderHeight,\n      itemWidth,\n      itemHeight,\n      vertical,\n      activeSlideAlignment\n    } = this.props;\n    if (activeSlideAlignment === 'start' && !opposite || activeSlideAlignment === 'end' && opposite) {\n      return 0;\n    } else if (activeSlideAlignment === 'end' && !opposite || activeSlideAlignment === 'start' && opposite) {\n      return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n    } else {\n      return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n    }\n  }\n  _getViewportOffset() {\n    const {\n      sliderWidth,\n      sliderHeight,\n      itemWidth,\n      itemHeight,\n      vertical,\n      activeSlideAlignment\n    } = this.props;\n    if (activeSlideAlignment === 'start') {\n      return vertical ? itemHeight / 2 : itemWidth / 2;\n    } else if (activeSlideAlignment === 'end') {\n      return vertical ? sliderHeight - itemHeight / 2 : sliderWidth - itemWidth / 2;\n    } else {\n      return vertical ? sliderHeight / 2 : sliderWidth / 2;\n    }\n  }\n  _getCenter(offset) {\n    return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n  }\n  _getActiveItem(offset) {\n    const {\n      activeSlideOffset,\n      swipeThreshold\n    } = this.props;\n    const center = this._getCenter(offset);\n    const centerOffset = activeSlideOffset || swipeThreshold;\n    for (let i = 0; i < this._positions.length; i++) {\n      const {\n        start,\n        end\n      } = this._positions[i];\n      if (center + centerOffset >= start && center - centerOffset <= end) {\n        return i;\n      }\n    }\n    const lastIndex = this._positions.length - 1;\n    if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n      return lastIndex;\n    }\n    return 0;\n  }\n  _initPositionsAndInterpolators(props = this.props) {\n    const {\n      data,\n      itemWidth,\n      itemHeight,\n      scrollInterpolator,\n      vertical\n    } = props;\n    const sizeRef = vertical ? itemHeight : itemWidth;\n    if (!data || !data.length) {\n      return;\n    }\n    let interpolators = [];\n    this._positions = [];\n    this._getCustomData(props).forEach((itemData, index) => {\n      const _index = this._getCustomIndex(index, props);\n      let animatedValue;\n      this._positions[index] = {\n        start: index * sizeRef,\n        end: index * sizeRef + sizeRef\n      };\n      if (!this._shouldAnimateSlides(props)) {\n        animatedValue = new Animated.Value(1);\n      } else if (this._shouldUseCustomAnimation()) {\n        animatedValue = new Animated.Value(_index === this._activeItem ? 1 : 0);\n      } else {\n        let interpolator;\n        if (scrollInterpolator) {\n          interpolator = scrollInterpolator(_index, props);\n        } else if (this._shouldUseStackLayout()) {\n          interpolator = stackScrollInterpolator(_index, props);\n        } else if (this._shouldUseTinderLayout()) {\n          interpolator = tinderScrollInterpolator(_index, props);\n        }\n        if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n          interpolator = defaultScrollInterpolator(_index, props);\n        }\n        animatedValue = this._scrollPos.interpolate(Object.assign({}, interpolator, {\n          extrapolate: 'clamp'\n        }));\n      }\n      interpolators.push(animatedValue);\n    });\n    this.setState({\n      interpolators\n    });\n  }\n  _getSlideAnimation(index, toValue) {\n    const {\n      interpolators\n    } = this.state;\n    const {\n      activeAnimationType,\n      activeAnimationOptions\n    } = this.props;\n    const animatedValue = interpolators && interpolators[index];\n    if (!animatedValue && animatedValue !== 0) {\n      return null;\n    }\n    const animationCommonOptions = Object.assign({\n      isInteraction: false,\n      useNativeDriver: true\n    }, activeAnimationOptions, {\n      toValue: toValue\n    });\n    return Animated.parallel([Animated['timing'](animatedValue, Object.assign({}, animationCommonOptions, {\n      easing: Easing.linear\n    })), Animated[activeAnimationType](animatedValue, Object.assign({}, animationCommonOptions))]);\n  }\n  _playCustomSlideAnimation(current, next) {\n    const {\n      interpolators\n    } = this.state;\n    const itemsLength = this._getCustomDataLength();\n    const _currentIndex = this._getCustomIndex(current);\n    const _currentDataIndex = this._getDataIndex(_currentIndex);\n    const _nextIndex = this._getCustomIndex(next);\n    const _nextDataIndex = this._getDataIndex(_nextIndex);\n    let animations = [];\n    if (this._enableLoop()) {\n      for (let i = 0; i < itemsLength; i++) {\n        if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n          animations.push(this._getSlideAnimation(i, 0));\n        } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n          animations.push(this._getSlideAnimation(i, 1));\n        }\n      }\n    } else {\n      if (interpolators[current]) {\n        animations.push(this._getSlideAnimation(current, 0));\n      }\n      if (interpolators[next]) {\n        animations.push(this._getSlideAnimation(next, 1));\n      }\n    }\n    Animated.parallel(animations, {\n      stopTogether: false\n    }).start();\n  }\n  _hackActiveSlideAnimation(index, goTo, force = false) {\n    const {\n      data\n    } = this.props;\n    if (!this._mounted || !this._carouselRef || !this._positions[index] || !force && this._enableLoop()) {\n      return;\n    }\n    const offset = this._positions[index] && this._positions[index].start;\n    if (!offset && offset !== 0) {\n      return;\n    }\n    const itemsLength = data && data.length;\n    const direction = goTo || itemsLength === 1 ? 'start' : 'end';\n    this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n    clearTimeout(this._hackSlideAnimationTimeout);\n    this._hackSlideAnimationTimeout = setTimeout(() => {\n      this._scrollTo(offset, false);\n    }, 50);\n  }\n  _lockScroll() {\n    const {\n      lockScrollTimeoutDuration\n    } = this.props;\n    clearTimeout(this._lockScrollTimeout);\n    this._lockScrollTimeout = setTimeout(() => {\n      this._releaseScroll();\n    }, lockScrollTimeoutDuration);\n    this._setScrollEnabled(false);\n  }\n  _releaseScroll() {\n    clearTimeout(this._lockScrollTimeout);\n    this._setScrollEnabled(true);\n  }\n  _repositionScroll(index) {\n    const {\n      data,\n      loopClonesPerSide\n    } = this.props;\n    const dataLength = data && data.length;\n    if (!this._enableLoop() || !dataLength || index >= loopClonesPerSide && index < dataLength + loopClonesPerSide) {\n      return;\n    }\n    let repositionTo = index;\n    if (index >= dataLength + loopClonesPerSide) {\n      repositionTo = index - dataLength;\n    } else if (index < loopClonesPerSide) {\n      repositionTo = index + dataLength;\n    }\n    this._snapToItem(repositionTo, false, false, false, false);\n  }\n  _scrollTo(offset, animated = true) {\n    const {\n      vertical\n    } = this.props;\n    const wrappedRef = this._getWrappedRef();\n    if (!this._mounted || !wrappedRef) {\n      return;\n    }\n    const specificOptions = this._needsScrollView() ? {\n      x: vertical ? 0 : offset,\n      y: vertical ? offset : 0\n    } : {\n      offset\n    };\n    const options = Object.assign({}, specificOptions, {\n      animated\n    });\n    if (this._needsScrollView()) {\n      wrappedRef.scrollTo(options);\n    } else {\n      wrappedRef.scrollToOffset(options);\n    }\n  }\n  _onScroll(event) {\n    const {\n      callbackOffsetMargin,\n      enableMomentum,\n      onScroll\n    } = this.props;\n    const scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n    const nextActiveItem = this._getActiveItem(scrollOffset);\n    const itemReached = nextActiveItem === this._itemToSnapTo;\n    const scrollConditions = scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin && scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n    this._currentContentOffset = scrollOffset;\n    this._onScrollTriggered = true;\n    this._lastScrollDate = Date.now();\n    if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n      this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n    }\n    if (enableMomentum) {\n      clearTimeout(this._snapNoMomentumTimeout);\n      if (this._activeItem !== nextActiveItem) {\n        this._activeItem = nextActiveItem;\n      }\n      if (itemReached) {\n        if (this._canFireBeforeCallback) {\n          this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n        }\n        if (scrollConditions && this._canFireCallback) {\n          this._onSnap(this._getDataIndex(nextActiveItem));\n        }\n      }\n    } else if (this._activeItem !== nextActiveItem && itemReached) {\n      if (this._canFireBeforeCallback) {\n        this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n      }\n      if (scrollConditions) {\n        this._activeItem = nextActiveItem;\n        if (this._canLockScroll()) {\n          this._releaseScroll();\n        }\n        if (this._canFireCallback) {\n          this._onSnap(this._getDataIndex(nextActiveItem));\n        }\n      }\n    }\n    if (nextActiveItem === this._itemToSnapTo && scrollOffset === this._scrollOffsetRef) {\n      this._repositionScroll(nextActiveItem);\n    }\n    if (typeof onScroll === \"function\" && event) {\n      onScroll(event);\n    }\n  }\n  _onStartShouldSetResponderCapture(event) {\n    const {\n      onStartShouldSetResponderCapture\n    } = this.props;\n    if (onStartShouldSetResponderCapture) {\n      onStartShouldSetResponderCapture(event);\n    }\n    return this._getScrollEnabled();\n  }\n  _onTouchStart() {\n    const {\n      onTouchStart\n    } = this.props;\n    if (this._getScrollEnabled() !== false && this._autoplaying) {\n      this.pauseAutoPlay();\n    }\n    if (onTouchStart) {\n      onTouchStart();\n    }\n  }\n  _onTouchEnd() {\n    const {\n      onTouchEnd\n    } = this.props;\n    if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n      this.startAutoplay();\n    }\n    if (onTouchEnd) {\n      onTouchEnd();\n    }\n  }\n  _onScrollBeginDrag(event) {\n    const {\n      onScrollBeginDrag\n    } = this.props;\n    if (!this._getScrollEnabled()) {\n      return;\n    }\n    this._scrollStartOffset = this._getScrollOffset(event);\n    this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n    this._ignoreNextMomentum = false;\n    if (onScrollBeginDrag) {\n      onScrollBeginDrag(event);\n    }\n  }\n  _onScrollEndDrag(event) {\n    const {\n      onScrollEndDrag\n    } = this.props;\n    if (this._carouselRef) {\n      this._onScrollEnd && this._onScrollEnd();\n    }\n    if (onScrollEndDrag) {\n      onScrollEndDrag(event);\n    }\n  }\n  _onMomentumScrollEnd(event) {\n    const {\n      onMomentumScrollEnd\n    } = this.props;\n    if (this._carouselRef) {\n      this._onScrollEnd && this._onScrollEnd();\n    }\n    if (onMomentumScrollEnd) {\n      onMomentumScrollEnd(event);\n    }\n  }\n  _onScrollEnd(event) {\n    const {\n      autoplayDelay,\n      enableSnap\n    } = this.props;\n    if (this._ignoreNextMomentum) {\n      this._ignoreNextMomentum = false;\n      return;\n    }\n    if (this._currentContentOffset === this._scrollEndOffset) {\n      return;\n    }\n    this._scrollEndOffset = this._currentContentOffset;\n    this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n    if (enableSnap) {\n      this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n    }\n    if (this._autoplay && !this._autoplaying) {\n      clearTimeout(this._enableAutoplayTimeout);\n      this._enableAutoplayTimeout = setTimeout(() => {\n        this.startAutoplay();\n      }, autoplayDelay + 50);\n    }\n  }\n  _onTouchRelease(event) {\n    const {\n      enableMomentum\n    } = this.props;\n    if (enableMomentum && IS_IOS) {\n      clearTimeout(this._snapNoMomentumTimeout);\n      this._snapNoMomentumTimeout = setTimeout(() => {\n        this._snapToItem(this._activeItem);\n      }, 100);\n    }\n  }\n  _onLayout(event) {\n    const {\n      onLayout\n    } = this.props;\n    if (this._onLayoutInitDone) {\n      this._initPositionsAndInterpolators();\n      this._snapToItem(this._activeItem, false, false, false, false);\n    } else {\n      this._onLayoutInitDone = true;\n    }\n    if (onLayout) {\n      onLayout(event);\n    }\n  }\n  _snapScroll(delta) {\n    const {\n      swipeThreshold\n    } = this.props;\n    if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n      this._scrollEndActive = this._scrollStartActive;\n    }\n    if (this._scrollStartActive !== this._scrollEndActive) {\n      this._snapToItem(this._scrollEndActive);\n    } else {\n      if (delta > 0) {\n        if (delta > swipeThreshold) {\n          this._snapToItem(this._scrollStartActive + 1);\n        } else {\n          this._snapToItem(this._scrollEndActive);\n        }\n      } else if (delta < 0) {\n        if (delta < -swipeThreshold) {\n          this._snapToItem(this._scrollStartActive - 1);\n        } else {\n          this._snapToItem(this._scrollEndActive);\n        }\n      } else {\n        this._snapToItem(this._scrollEndActive);\n      }\n    }\n  }\n  _snapToItem(index, animated = true, fireCallback = true, initial = false, lockScroll = true) {\n    const {\n      enableMomentum,\n      onSnapToItem,\n      onBeforeSnapToItem\n    } = this.props;\n    const itemsLength = this._getCustomDataLength();\n    const wrappedRef = this._getWrappedRef();\n    if (!itemsLength || !wrappedRef) {\n      return;\n    }\n    if (!index || index < 0) {\n      index = 0;\n    } else if (itemsLength > 0 && index >= itemsLength) {\n      index = itemsLength - 1;\n    }\n    if (index !== this._previousActiveItem) {\n      this._previousActiveItem = index;\n      if (lockScroll && this._canLockScroll()) {\n        this._lockScroll();\n      }\n      if (fireCallback) {\n        if (onBeforeSnapToItem) {\n          this._canFireBeforeCallback = true;\n        }\n        if (onSnapToItem) {\n          this._canFireCallback = true;\n        }\n      }\n    }\n    this._itemToSnapTo = index;\n    this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n    this._onScrollTriggered = false;\n    if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n      return;\n    }\n    this._scrollTo(this._scrollOffsetRef, animated);\n    this._scrollEndOffset = this._currentContentOffset;\n    if (enableMomentum) {\n      if (!initial) {\n        this._ignoreNextMomentum = true;\n      }\n      if (index === 0 || index === itemsLength - 1) {\n        clearTimeout(this._edgeItemTimeout);\n        this._edgeItemTimeout = setTimeout(() => {\n          if (!initial && index === this._activeItem && !this._onScrollTriggered) {\n            this._onScroll();\n          }\n        }, 250);\n      }\n    }\n  }\n  _onBeforeSnap(index) {\n    const {\n      onBeforeSnapToItem\n    } = this.props;\n    if (!this._carouselRef) {\n      return;\n    }\n    this._canFireBeforeCallback = false;\n    onBeforeSnapToItem && onBeforeSnapToItem(index);\n  }\n  _onSnap(index) {\n    const {\n      onSnapToItem\n    } = this.props;\n    if (!this._carouselRef) {\n      return;\n    }\n    this._canFireCallback = false;\n    onSnapToItem && onSnapToItem(index);\n  }\n  startAutoplay() {\n    const {\n      autoplayInterval,\n      autoplayDelay\n    } = this.props;\n    this._autoplay = true;\n    if (this._autoplaying) {\n      return;\n    }\n    clearTimeout(this._autoplayTimeout);\n    this._autoplayTimeout = setTimeout(() => {\n      this._autoplaying = true;\n      this._autoplayInterval = setInterval(() => {\n        if (this._autoplaying) {\n          this.snapToNext();\n        }\n      }, autoplayInterval);\n    }, autoplayDelay);\n  }\n  pauseAutoPlay() {\n    this._autoplaying = false;\n    clearTimeout(this._autoplayTimeout);\n    clearTimeout(this._enableAutoplayTimeout);\n    clearInterval(this._autoplayInterval);\n  }\n  stopAutoplay() {\n    this._autoplay = false;\n    this.pauseAutoPlay();\n  }\n  snapToItem(index, animated = true, fireCallback = true) {\n    if (!index || index < 0) {\n      index = 0;\n    }\n    const positionIndex = this._getPositionIndex(index);\n    if (positionIndex === this._activeItem) {\n      return;\n    }\n    this._snapToItem(positionIndex, animated, fireCallback);\n  }\n  snapToNext(animated = true, fireCallback = true) {\n    const itemsLength = this._getCustomDataLength();\n    let newIndex = this._activeItem + 1;\n    if (newIndex > itemsLength - 1) {\n      if (!this._enableLoop()) {\n        return;\n      }\n      newIndex = 0;\n    }\n    this._snapToItem(newIndex, animated, fireCallback);\n  }\n  snapToPrev(animated = true, fireCallback = true) {\n    const itemsLength = this._getCustomDataLength();\n    let newIndex = this._activeItem - 1;\n    if (newIndex < 0) {\n      if (!this._enableLoop()) {\n        return;\n      }\n      newIndex = itemsLength - 1;\n    }\n    this._snapToItem(newIndex, animated, fireCallback);\n  }\n  triggerRenderingHack(offset) {\n    if (Date.now() - this._lastScrollDate < 500) {\n      return;\n    }\n    const scrollPosition = this._currentContentOffset;\n    if (!scrollPosition && scrollPosition !== 0) {\n      return;\n    }\n    const scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n    this._scrollTo(scrollPosition + scrollOffset, false);\n  }\n  _getSlideInterpolatedStyle(index, animatedValue) {\n    const {\n      layoutCardOffset,\n      slideInterpolatedStyle\n    } = this.props;\n    if (slideInterpolatedStyle) {\n      return slideInterpolatedStyle(index, animatedValue, this.props);\n    } else if (this._shouldUseTinderLayout()) {\n      return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n    } else if (this._shouldUseStackLayout()) {\n      return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n    } else if (this._shouldUseShiftLayout()) {\n      return shiftAnimatedStyles(index, animatedValue, this.props);\n    } else {\n      return defaultAnimatedStyles(index, animatedValue, this.props);\n    }\n  }\n  _renderItem({\n    item,\n    index\n  }) {\n    const {\n      interpolators\n    } = this.state;\n    const {\n      hasParallaxImages,\n      itemWidth,\n      itemHeight,\n      keyExtractor,\n      renderItem,\n      sliderHeight,\n      sliderWidth,\n      slideStyle,\n      vertical\n    } = this.props;\n    const animatedValue = interpolators && interpolators[index];\n    if (!animatedValue && animatedValue !== 0) {\n      return null;\n    }\n    const animate = this._shouldAnimateSlides();\n    const Component = animate ? Animated.View : View;\n    const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n    const parallaxProps = hasParallaxImages ? {\n      scrollPosition: this._scrollPos,\n      carouselRef: this._carouselRef,\n      vertical,\n      sliderWidth,\n      sliderHeight,\n      itemWidth,\n      itemHeight\n    } : undefined;\n    const mainDimension = vertical ? {\n      height: itemHeight\n    } : {\n      width: itemWidth\n    };\n    const specificProps = this._needsScrollView() ? {\n      key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n    } : {};\n    return _jsxDEV(Component, Object.assign({\n      style: [mainDimension, slideStyle, animatedStyle],\n      pointerEvents: 'box-none'\n    }, specificProps, {\n      children: renderItem({\n        item,\n        index\n      }, parallaxProps)\n    }), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1237,\n      columnNumber: 13\n    }, this);\n  }\n  _getComponentOverridableProps() {\n    const {\n      enableMomentum,\n      itemWidth,\n      itemHeight,\n      loopClonesPerSide,\n      sliderWidth,\n      sliderHeight,\n      vertical\n    } = this.props;\n    const visibleItems = Math.ceil(vertical ? sliderHeight / itemHeight : sliderWidth / itemWidth) + 1;\n    const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n    const initialNumToRender = visibleItems + initialNumPerSide * 2;\n    const maxToRenderPerBatch = 1 + initialNumToRender * 2;\n    const windowSize = maxToRenderPerBatch;\n    const specificProps = !this._needsScrollView() ? {\n      initialNumToRender: initialNumToRender,\n      maxToRenderPerBatch: maxToRenderPerBatch,\n      windowSize: windowSize\n    } : {};\n    return Object.assign({\n      decelerationRate: enableMomentum ? 0.9 : 'fast',\n      showsHorizontalScrollIndicator: false,\n      showsVerticalScrollIndicator: false,\n      overScrollMode: 'never',\n      automaticallyAdjustContentInsets: false,\n      directionalLockEnabled: true,\n      pinchGestureEnabled: false,\n      scrollsToTop: false,\n      removeClippedSubviews: !this._needsScrollView(),\n      inverted: this._needsRTLAdaptations()\n    }, specificProps);\n  }\n  _getComponentStaticProps() {\n    const {\n      hideCarousel\n    } = this.state;\n    const {\n      containerCustomStyle,\n      contentContainerCustomStyle,\n      keyExtractor,\n      sliderWidth,\n      sliderHeight,\n      style,\n      vertical\n    } = this.props;\n    const containerStyle = [containerCustomStyle || style || {}, hideCarousel ? {\n      opacity: 0\n    } : {}, vertical ? {\n      height: sliderHeight,\n      flexDirection: 'column'\n    } : {\n      width: sliderWidth,\n      flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row'\n    }];\n    const contentContainerStyle = [vertical ? {\n      paddingTop: this._getContainerInnerMargin(),\n      paddingBottom: this._getContainerInnerMargin(true)\n    } : {\n      paddingLeft: this._getContainerInnerMargin(),\n      paddingRight: this._getContainerInnerMargin(true)\n    }, contentContainerCustomStyle || {}];\n    const specificProps = !this._needsScrollView() ? {\n      renderItem: this._renderItem,\n      numColumns: 1,\n      keyExtractor: keyExtractor || this._getKeyExtractor\n    } : {};\n    return Object.assign({\n      ref: c => this._carouselRef = c,\n      data: this._getCustomData(),\n      style: containerStyle,\n      contentContainerStyle: contentContainerStyle,\n      horizontal: !vertical,\n      scrollEventThrottle: 1,\n      onScroll: this._onScrollHandler,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      onResponderRelease: this._onTouchRelease,\n      onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n      onTouchStart: this._onTouchStart,\n      onTouchEnd: this._onScrollEnd,\n      onLayout: this._onLayout\n    }, specificProps);\n  }\n  render() {\n    const {\n      data,\n      renderItem,\n      useScrollView\n    } = this.props;\n    if (!data || !renderItem) {\n      return null;\n    }\n    const props = Object.assign({}, this._getComponentOverridableProps(), this.props, this._getComponentStaticProps());\n    const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView;\n    return this._needsScrollView() ? _jsxDEV(ScrollViewComponent, Object.assign({}, props, {\n      children: this._getCustomData().map((item, index) => {\n        return this._renderItem({\n          item,\n          index\n        });\n      })\n    }), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1360,\n      columnNumber: 13\n    }, this) : _jsxDEV(AnimatedFlatList, Object.assign({}, props), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1368,\n      columnNumber: 13\n    }, this);\n  }\n}","map":{"version":3,"names":["React","Component","Animated","Easing","FlatList","I18nManager","Platform","ScrollView","View","ViewPropTypes","PropTypes","shallowCompare","defaultScrollInterpolator","stackScrollInterpolator","tinderScrollInterpolator","defaultAnimatedStyles","shiftAnimatedStyles","stackAnimatedStyles","tinderAnimatedStyles","jsxDEV","_jsxDEV","IS_IOS","OS","AnimatedFlatList","createAnimatedComponent","AnimatedScrollView","IS_RTL","isRTL","Carousel","propTypes","data","array","isRequired","renderItem","func","itemWidth","number","itemHeight","sliderWidth","sliderHeight","activeAnimationType","string","activeAnimationOptions","object","activeSlideAlignment","oneOf","activeSlideOffset","apparitionDelay","autoplay","bool","autoplayDelay","autoplayInterval","callbackOffsetMargin","containerCustomStyle","style","contentContainerCustomStyle","enableMomentum","enableSnap","firstItem","hasParallaxImages","inactiveSlideOpacity","inactiveSlideScale","inactiveSlideShift","layout","layoutCardOffset","lockScrollTimeoutDuration","lockScrollWhileSnapping","loop","loopClonesPerSide","scrollEnabled","scrollInterpolator","slideInterpolatedStyle","slideStyle","shouldOptimizeUpdates","swipeThreshold","useScrollView","oneOfType","vertical","onBeforeSnapToItem","onSnapToItem","defaultProps","constructor","props","state","hideCarousel","interpolators","initialActiveItem","_getFirstItem","_activeItem","_previousActiveItem","_previousFirstItem","_previousItemsLength","_mounted","_positions","_currentContentOffset","_canFireBeforeCallback","_canFireCallback","_scrollOffsetRef","_onScrollTriggered","_lastScrollDate","_scrollEnabled","_initPositionsAndInterpolators","bind","_renderItem","_onSnap","_onLayout","_onScroll","_onScrollBeginDrag","undefined","_onScrollEnd","_onScrollEndDrag","_onMomentumScrollEnd","_onTouchStart","_onTouchEnd","_onTouchRelease","_getKeyExtractor","_setScrollHandler","_ignoreNextMomentum","console","warn","error","customAnimationType","customAnimationOptions","onScrollViewScroll","componentDidMount","_firstItem","apparitionCallback","setState","startAutoplay","requestAnimationFrame","_snapToItem","_hackActiveSlideAnimation","_apparitionTimeout","setTimeout","shouldComponentUpdate","nextProps","nextState","componentDidUpdate","prevProps","itemsLength","_getCustomDataLength","nextFirstItem","nextActiveItem","hasNewSliderWidth","hasNewSliderHeight","hasNewItemWidth","hasNewItemHeight","hasNewScrollEnabled","_setScrollEnabled","length","onScroll","componentWillUnmount","stopAutoplay","clearTimeout","_hackSlideAnimationTimeout","_enableAutoplayTimeout","_autoplayTimeout","_snapNoMomentumTimeout","_edgeItemTimeout","_lockScrollTimeout","realIndex","currentIndex","_getDataIndex","currentScrollPosition","scrollEventConfig","listener","useNativeDriver","_scrollPos","Value","argMapping","nativeEvent","contentOffset","y","x","Array","isArray","_argMapping","pop","argMap","push","_onScrollHandler","event","_needsScrollView","_shouldUseStackLayout","_shouldUseTinderLayout","_needsRTLAdaptations","_canLockScroll","_enableLoop","_shouldAnimateSlides","_shouldUseShiftLayout","_shouldUseCustomAnimation","_getCustomData","dataLength","previousItems","nextItems","dataMultiplier","Math","floor","remainder","i","unshift","slice","concat","_getCustomIndex","index","baseDataIndexes","dataIndexes","j","_getPositionIndex","_getWrappedRef","_carouselRef","scrollTo","scrollToOffset","getNode","_getScrollEnabled","wrappedRef","setNativeProps","item","_getScrollOffset","_getContainerInnerMargin","opposite","_getViewportOffset","_getCenter","offset","_getActiveItem","center","centerOffset","start","end","lastIndex","sizeRef","forEach","itemData","_index","animatedValue","interpolator","inputRange","outputRange","interpolate","Object","assign","extrapolate","_getSlideAnimation","toValue","animationCommonOptions","isInteraction","parallel","easing","linear","_playCustomSlideAnimation","current","next","_currentIndex","_currentDataIndex","_nextIndex","_nextDataIndex","animations","stopTogether","goTo","force","direction","_scrollTo","_lockScroll","_releaseScroll","_repositionScroll","repositionTo","animated","specificOptions","options","scrollOffset","itemReached","_itemToSnapTo","scrollConditions","Date","now","_onBeforeSnap","_onStartShouldSetResponderCapture","onStartShouldSetResponderCapture","onTouchStart","_autoplaying","pauseAutoPlay","onTouchEnd","_autoplay","onScrollBeginDrag","_scrollStartOffset","_scrollStartActive","onScrollEndDrag","onMomentumScrollEnd","_scrollEndOffset","_scrollEndActive","_snapScroll","onLayout","_onLayoutInitDone","delta","fireCallback","initial","lockScroll","_autoplayInterval","setInterval","snapToNext","clearInterval","snapToItem","positionIndex","newIndex","snapToPrev","triggerRenderingHack","scrollPosition","_getSlideInterpolatedStyle","keyExtractor","animate","animatedStyle","parallaxProps","carouselRef","mainDimension","height","width","specificProps","key","pointerEvents","children","fileName","_jsxFileName","lineNumber","columnNumber","_getComponentOverridableProps","visibleItems","ceil","initialNumPerSide","initialNumToRender","maxToRenderPerBatch","windowSize","decelerationRate","showsHorizontalScrollIndicator","showsVerticalScrollIndicator","overScrollMode","automaticallyAdjustContentInsets","directionalLockEnabled","pinchGestureEnabled","scrollsToTop","removeClippedSubviews","inverted","_getComponentStaticProps","containerStyle","opacity","flexDirection","contentContainerStyle","paddingTop","paddingBottom","paddingLeft","paddingRight","numColumns","ref","c","horizontal","scrollEventThrottle","onResponderRelease","render","ScrollViewComponent","map"],"sources":["F:/Aftab-at-Wafi/Projects/WafiCommerce-mobile/WafiCommerce/node_modules/react-native-snap-carousel/src/carousel/Carousel.js"],"sourcesContent":["import React, { Component } from 'react';\nimport { Animated, Easing, FlatList, I18nManager, Platform, ScrollView, View, ViewPropTypes } from 'react-native';\nimport PropTypes from 'prop-types';\nimport shallowCompare from 'react-addons-shallow-compare';\nimport {\n    defaultScrollInterpolator,\n    stackScrollInterpolator,\n    tinderScrollInterpolator,\n    defaultAnimatedStyles,\n    shiftAnimatedStyles,\n    stackAnimatedStyles,\n    tinderAnimatedStyles\n} from '../utils/animations';\n\nconst IS_IOS = Platform.OS === 'ios';\n\n// Native driver for scroll events\n// See: https://facebook.github.io/react-native/blog/2017/02/14/using-native-driver-for-animated.html\nconst AnimatedFlatList = FlatList ? Animated.createAnimatedComponent(FlatList) : null;\nconst AnimatedScrollView = Animated.createAnimatedComponent(ScrollView);\n\n// React Native automatically handles RTL layouts; unfortunately, it's buggy with horizontal ScrollView\n// See https://github.com/facebook/react-native/issues/11960\n// NOTE: the following variable is not declared in the constructor\n// otherwise it is undefined at init, which messes with custom indexes\nconst IS_RTL = I18nManager.isRTL;\n\nexport default class Carousel extends Component {\n\n    static propTypes = {\n        data: PropTypes.array.isRequired,\n        renderItem: PropTypes.func.isRequired,\n        itemWidth: PropTypes.number, // required for horizontal carousel\n        itemHeight: PropTypes.number, // required for vertical carousel\n        sliderWidth: PropTypes.number, // required for horizontal carousel\n        sliderHeight: PropTypes.number, // required for vertical carousel\n        activeAnimationType: PropTypes.string,\n        activeAnimationOptions: PropTypes.object,\n        activeSlideAlignment: PropTypes.oneOf(['center', 'end', 'start']),\n        activeSlideOffset: PropTypes.number,\n        apparitionDelay: PropTypes.number,\n        autoplay: PropTypes.bool,\n        autoplayDelay: PropTypes.number,\n        autoplayInterval: PropTypes.number,\n        callbackOffsetMargin: PropTypes.number,\n        containerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        contentContainerCustomStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        enableMomentum: PropTypes.bool,\n        enableSnap: PropTypes.bool,\n        firstItem: PropTypes.number,\n        hasParallaxImages: PropTypes.bool,\n        inactiveSlideOpacity: PropTypes.number,\n        inactiveSlideScale: PropTypes.number,\n        inactiveSlideShift: PropTypes.number,\n        layout: PropTypes.oneOf(['default', 'stack', 'tinder']),\n        layoutCardOffset: PropTypes.number,\n        lockScrollTimeoutDuration: PropTypes.number,\n        lockScrollWhileSnapping: PropTypes.bool,\n        loop: PropTypes.bool,\n        loopClonesPerSide: PropTypes.number,\n        scrollEnabled: PropTypes.bool,\n        scrollInterpolator: PropTypes.func,\n        slideInterpolatedStyle: PropTypes.func,\n        slideStyle: ViewPropTypes ? ViewPropTypes.style : View.propTypes.style,\n        shouldOptimizeUpdates: PropTypes.bool,\n        swipeThreshold: PropTypes.number,\n        useScrollView: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n        vertical: PropTypes.bool,\n        onBeforeSnapToItem: PropTypes.func,\n        onSnapToItem: PropTypes.func\n    };\n\n    static defaultProps = {\n        activeAnimationType: 'timing',\n        activeAnimationOptions: null,\n        activeSlideAlignment: 'center',\n        activeSlideOffset: 20,\n        apparitionDelay: 0,\n        autoplay: false,\n        autoplayDelay: 1000,\n        autoplayInterval: 3000,\n        callbackOffsetMargin: 5,\n        containerCustomStyle: {},\n        contentContainerCustomStyle: {},\n        enableMomentum: false,\n        enableSnap: true,\n        firstItem: 0,\n        hasParallaxImages: false,\n        inactiveSlideOpacity: 0.7,\n        inactiveSlideScale: 0.9,\n        inactiveSlideShift: 0,\n        layout: 'default',\n        lockScrollTimeoutDuration: 1000,\n        lockScrollWhileSnapping: false,\n        loop: false,\n        loopClonesPerSide: 3,\n        scrollEnabled: true,\n        slideStyle: {},\n        shouldOptimizeUpdates: true,\n        swipeThreshold: 20,\n        useScrollView: !AnimatedFlatList,\n        vertical: false\n    }\n\n    constructor (props) {\n        super(props);\n\n        this.state = {\n            hideCarousel: true,\n            interpolators: []\n        };\n\n        // The following values are not stored in the state because 'setState()' is asynchronous\n        // and this results in an absolutely crappy behavior on Android while swiping (see #156)\n        const initialActiveItem = this._getFirstItem(props.firstItem);\n        this._activeItem = initialActiveItem;\n        this._previousActiveItem = initialActiveItem;\n        this._previousFirstItem = initialActiveItem;\n        this._previousItemsLength = initialActiveItem;\n\n        this._mounted = false;\n        this._positions = [];\n        this._currentContentOffset = 0; // store ScrollView's scroll position\n        this._canFireBeforeCallback = false;\n        this._canFireCallback = false;\n        this._scrollOffsetRef = null;\n        this._onScrollTriggered = true; // used when momentum is enabled to prevent an issue with edges items\n        this._lastScrollDate = 0; // used to work around a FlatList bug\n        this._scrollEnabled = props.scrollEnabled !== false;\n\n        this._initPositionsAndInterpolators = this._initPositionsAndInterpolators.bind(this);\n        this._renderItem = this._renderItem.bind(this);\n        this._onSnap = this._onSnap.bind(this);\n\n        this._onLayout = this._onLayout.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this._onScrollBeginDrag = props.enableSnap ? this._onScrollBeginDrag.bind(this) : undefined;\n        this._onScrollEnd = props.enableSnap || props.autoplay ? this._onScrollEnd.bind(this) : undefined;\n        this._onScrollEndDrag = !props.enableMomentum ? this._onScrollEndDrag.bind(this) : undefined;\n        this._onMomentumScrollEnd = props.enableMomentum ? this._onMomentumScrollEnd.bind(this) : undefined;\n        this._onTouchStart = this._onTouchStart.bind(this);\n        this._onTouchEnd = this._onTouchEnd.bind(this);\n        this._onTouchRelease = this._onTouchRelease.bind(this);\n\n        this._getKeyExtractor = this._getKeyExtractor.bind(this);\n\n        this._setScrollHandler(props);\n\n        // This bool aims at fixing an iOS bug due to scrollTo that triggers onMomentumScrollEnd.\n        // onMomentumScrollEnd fires this._snapScroll, thus creating an infinite loop.\n        this._ignoreNextMomentum = false;\n\n        // Warnings\n        if (!ViewPropTypes) {\n            console.warn('react-native-snap-carousel: It is recommended to use at least version 0.44 of React Native with the plugin');\n        }\n        if (!props.vertical && (!props.sliderWidth || !props.itemWidth)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderWidth` and `itemWidth` for horizontal carousels');\n        }\n        if (props.vertical && (!props.sliderHeight || !props.itemHeight)) {\n            console.error('react-native-snap-carousel: You need to specify both `sliderHeight` and `itemHeight` for vertical carousels');\n        }\n        if (props.apparitionDelay && !IS_IOS && !props.useScrollView) {\n            console.warn('react-native-snap-carousel: Using `apparitionDelay` on Android is not recommended since it can lead to rendering issues');\n        }\n        if (props.customAnimationType || props.customAnimationOptions) {\n            console.warn('react-native-snap-carousel: Props `customAnimationType` and `customAnimationOptions` have been renamed to `activeAnimationType` and `activeAnimationOptions`');\n        }\n        if (props.onScrollViewScroll) {\n            console.error('react-native-snap-carousel: Prop `onScrollViewScroll` has been removed. Use `onScroll` instead');\n        }\n    }\n\n    componentDidMount () {\n        const { apparitionDelay, autoplay, firstItem } = this.props;\n        const _firstItem = this._getFirstItem(firstItem);\n        const apparitionCallback = () => {\n            this.setState({ hideCarousel: false });\n            if (autoplay) {\n                this.startAutoplay();\n            }\n        };\n\n        this._mounted = true;\n        this._initPositionsAndInterpolators();\n\n        // Without 'requestAnimationFrame' or a `0` timeout, images will randomly not be rendered on Android...\n        requestAnimationFrame(() => {\n            if (!this._mounted) {\n                return;\n            }\n\n            this._snapToItem(_firstItem, false, false, true, false);\n            this._hackActiveSlideAnimation(_firstItem, 'start', true);\n\n            if (apparitionDelay) {\n                this._apparitionTimeout = setTimeout(() => {\n                    apparitionCallback();\n                }, apparitionDelay);\n            } else {\n                apparitionCallback();\n            }\n        });\n    }\n\n    shouldComponentUpdate (nextProps, nextState) {\n        if (this.props.shouldOptimizeUpdates === false) {\n            return true;\n        } else {\n            return shallowCompare(this, nextProps, nextState);\n        }\n    }\n\n    componentDidUpdate (prevProps) {\n        const { interpolators } = this.state;\n        const { firstItem, itemHeight, itemWidth, scrollEnabled, sliderHeight, sliderWidth } = this.props;\n        const itemsLength = this._getCustomDataLength(this.props);\n\n        if (!itemsLength) {\n            return;\n        }\n\n        const nextFirstItem = this._getFirstItem(firstItem, this.props);\n        let nextActiveItem = this._activeItem || this._activeItem === 0 ? this._activeItem : nextFirstItem;\n\n        const hasNewSliderWidth = sliderWidth && sliderWidth !== prevProps.sliderWidth;\n        const hasNewSliderHeight = sliderHeight && sliderHeight !== prevProps.sliderHeight;\n        const hasNewItemWidth = itemWidth && itemWidth !== prevProps.itemWidth;\n        const hasNewItemHeight = itemHeight && itemHeight !== prevProps.itemHeight;\n        const hasNewScrollEnabled = scrollEnabled !== prevProps.scrollEnabled;\n\n        // Prevent issues with dynamically removed items\n        if (nextActiveItem > itemsLength - 1) {\n            nextActiveItem = itemsLength - 1;\n        }\n\n        // Handle changing scrollEnabled independent of user -> carousel interaction\n        if (hasNewScrollEnabled) {\n            this._setScrollEnabled(scrollEnabled);\n        }\n\n        if (interpolators.length !== itemsLength || hasNewSliderWidth ||\n            hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n            this._activeItem = nextActiveItem;\n            this._previousItemsLength = itemsLength;\n\n            this._initPositionsAndInterpolators(this.props);\n\n            // Handle scroll issue when dynamically removing items (see #133)\n            // This also fixes first item's active state on Android\n            // Because 'initialScrollIndex' apparently doesn't trigger scroll\n            if (this._previousItemsLength > itemsLength) {\n                this._hackActiveSlideAnimation(nextActiveItem, null, true);\n            }\n\n            if (hasNewSliderWidth || hasNewSliderHeight || hasNewItemWidth || hasNewItemHeight) {\n                this._snapToItem(nextActiveItem, false, false, false, false);\n            }\n        } else if (nextFirstItem !== this._previousFirstItem && nextFirstItem !== this._activeItem) {\n            this._activeItem = nextFirstItem;\n            this._previousFirstItem = nextFirstItem;\n            this._snapToItem(nextFirstItem, false, true, false, false);\n        }\n\n        if (this.props.onScroll !== prevProps.onScroll) {\n          this._setScrollHandler(this.props);\n        }\n    }\n\n    componentWillUnmount () {\n        this._mounted = false;\n        this.stopAutoplay();\n        clearTimeout(this._apparitionTimeout);\n        clearTimeout(this._hackSlideAnimationTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._snapNoMomentumTimeout);\n        clearTimeout(this._edgeItemTimeout);\n        clearTimeout(this._lockScrollTimeout);\n    }\n\n    get realIndex () {\n        return this._activeItem;\n    }\n\n    get currentIndex () {\n        return this._getDataIndex(this._activeItem);\n    }\n\n    get currentScrollPosition () {\n        return this._currentContentOffset;\n    }\n\n    _setScrollHandler(props) {\n      // Native driver for scroll events\n      const scrollEventConfig = {\n        listener: this._onScroll,\n        useNativeDriver: true,\n      };\n      this._scrollPos = new Animated.Value(0);\n      const argMapping = props.vertical\n        ? [{ nativeEvent: { contentOffset: { y: this._scrollPos } } }]\n        : [{ nativeEvent: { contentOffset: { x: this._scrollPos } } }];\n\n      if (props.onScroll && Array.isArray(props.onScroll._argMapping)) {\n        // Because of a react-native issue https://github.com/facebook/react-native/issues/13294\n        argMapping.pop();\n        const [ argMap ] = props.onScroll._argMapping;\n        if (argMap && argMap.nativeEvent && argMap.nativeEvent.contentOffset) {\n          // Shares the same animated value passed in props\n          this._scrollPos =\n            argMap.nativeEvent.contentOffset.x ||\n            argMap.nativeEvent.contentOffset.y ||\n            this._scrollPos;\n        }\n        argMapping.push(...props.onScroll._argMapping);\n      }\n      this._onScrollHandler = Animated.event(\n        argMapping,\n        scrollEventConfig\n      );\n    }\n\n    _needsScrollView () {\n        const { useScrollView } = this.props;\n        return useScrollView || !AnimatedFlatList || this._shouldUseStackLayout() || this._shouldUseTinderLayout();\n    }\n\n    _needsRTLAdaptations () {\n        const { vertical } = this.props;\n        return IS_RTL && !IS_IOS && !vertical;\n    }\n\n    _canLockScroll () {\n        const { scrollEnabled, enableMomentum, lockScrollWhileSnapping } = this.props;\n        return scrollEnabled && !enableMomentum && lockScrollWhileSnapping;\n    }\n\n    _enableLoop () {\n        const { data, enableSnap, loop } = this.props;\n        return enableSnap && loop && data && data.length && data.length > 1;\n    }\n\n    _shouldAnimateSlides (props = this.props) {\n        const { inactiveSlideOpacity, inactiveSlideScale, scrollInterpolator, slideInterpolatedStyle } = props;\n        return inactiveSlideOpacity < 1 ||\n            inactiveSlideScale < 1 ||\n            !!scrollInterpolator ||\n            !!slideInterpolatedStyle ||\n            this._shouldUseShiftLayout() ||\n            this._shouldUseStackLayout() ||\n            this._shouldUseTinderLayout();\n    }\n\n    _shouldUseCustomAnimation () {\n        const { activeAnimationOptions } = this.props;\n        return !!activeAnimationOptions && !this._shouldUseStackLayout() && !this._shouldUseTinderLayout();\n    }\n\n    _shouldUseShiftLayout () {\n        const { inactiveSlideShift, layout } = this.props;\n        return layout === 'default' && inactiveSlideShift !== 0;\n    }\n\n    _shouldUseStackLayout () {\n        return this.props.layout === 'stack';\n    }\n\n    _shouldUseTinderLayout () {\n        return this.props.layout === 'tinder';\n    }\n\n    _getCustomData (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return [];\n        }\n\n        if (!this._enableLoop()) {\n            return data;\n        }\n\n        let previousItems = [];\n        let nextItems = [];\n\n        if (loopClonesPerSide > dataLength) {\n            const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n            const remainder = loopClonesPerSide % dataLength;\n\n            for (let i = 0; i < dataMultiplier; i++) {\n                previousItems.push(...data);\n                nextItems.push(...data);\n            }\n\n            previousItems.unshift(...data.slice(-remainder));\n            nextItems.push(...data.slice(0, remainder));\n        } else {\n            previousItems = data.slice(-loopClonesPerSide);\n            nextItems = data.slice(0, loopClonesPerSide);\n        }\n\n        return previousItems.concat(data, nextItems);\n    }\n\n    _getCustomDataLength (props = this.props) {\n        const { data, loopClonesPerSide } = props;\n        const dataLength = data && data.length;\n\n        if (!dataLength) {\n            return 0;\n        }\n\n        return this._enableLoop() ? dataLength + (2 * loopClonesPerSide) : dataLength;\n    }\n\n    _getCustomIndex (index, props = this.props) {\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || (!index && index !== 0)) {\n            return 0;\n        }\n\n        return this._needsRTLAdaptations() ? itemsLength - index - 1 : index;\n    }\n\n    _getDataIndex (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength) {\n            return index;\n        }\n\n        if (index >= dataLength + loopClonesPerSide) {\n            return loopClonesPerSide > dataLength ?\n                (index - loopClonesPerSide) % dataLength :\n                index - dataLength - loopClonesPerSide;\n        } else if (index < loopClonesPerSide) {\n            // TODO: is there a simpler way of determining the interpolated index?\n            if (loopClonesPerSide > dataLength) {\n                const baseDataIndexes = [];\n                const dataIndexes = [];\n                const dataMultiplier = Math.floor(loopClonesPerSide / dataLength);\n                const remainder = loopClonesPerSide % dataLength;\n\n                for (let i = 0; i < dataLength; i++) {\n                    baseDataIndexes.push(i);\n                }\n\n                for (let j = 0; j < dataMultiplier; j++) {\n                    dataIndexes.push(...baseDataIndexes);\n                }\n\n                dataIndexes.unshift(...baseDataIndexes.slice(-remainder));\n                return dataIndexes[index];\n            } else {\n                return index + dataLength - loopClonesPerSide;\n            }\n        } else {\n            return index - loopClonesPerSide;\n        }\n    }\n\n    // Used with `snapToItem()` and 'PaginationDot'\n    _getPositionIndex (index) {\n        const { loop, loopClonesPerSide } = this.props;\n        return loop ? index + loopClonesPerSide : index;\n    }\n\n    _getFirstItem (index, props = this.props) {\n        const { loopClonesPerSide } = props;\n        const itemsLength = this._getCustomDataLength(props);\n\n        if (!itemsLength || index > itemsLength - 1 || index < 0) {\n            return 0;\n        }\n\n        return this._enableLoop() ? index + loopClonesPerSide : index;\n    }\n\n    _getWrappedRef () {\n        if (this._carouselRef && (\n            (this._needsScrollView() && this._carouselRef.scrollTo) ||\n            (!this._needsScrollView() && this._carouselRef.scrollToOffset)\n        )) {\n            return this._carouselRef;\n        }\n        // https://github.com/facebook/react-native/issues/10635\n        // https://stackoverflow.com/a/48786374/8412141\n        return this._carouselRef && this._carouselRef.getNode && this._carouselRef.getNode();\n    }\n\n    _getScrollEnabled () {\n        return this._scrollEnabled;\n    }\n\n    _setScrollEnabled (scrollEnabled = true) {\n        const wrappedRef = this._getWrappedRef();\n\n        if (!wrappedRef || !wrappedRef.setNativeProps) {\n            return;\n        }\n\n        // 'setNativeProps()' is used instead of 'setState()' because the latter\n        // really takes a toll on Android behavior when momentum is disabled\n        wrappedRef.setNativeProps({ scrollEnabled });\n        this._scrollEnabled = scrollEnabled;\n    }\n\n    _getKeyExtractor (item, index) {\n        return this._needsScrollView() ? `scrollview-item-${index}` : `flatlist-item-${index}`;\n    }\n\n    _getScrollOffset (event) {\n        const { vertical } = this.props;\n        return (event && event.nativeEvent && event.nativeEvent.contentOffset &&\n            event.nativeEvent.contentOffset[vertical ? 'y' : 'x']) || 0;\n    }\n\n    _getContainerInnerMargin (opposite = false) {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if ((activeSlideAlignment === 'start' && !opposite) ||\n            (activeSlideAlignment === 'end' && opposite)) {\n            return 0;\n        } else if ((activeSlideAlignment === 'end' && !opposite) ||\n            (activeSlideAlignment === 'start' && opposite)) {\n            return vertical ? sliderHeight - itemHeight : sliderWidth - itemWidth;\n        } else {\n            return vertical ? (sliderHeight - itemHeight) / 2 : (sliderWidth - itemWidth) / 2;\n        }\n    }\n\n    _getViewportOffset () {\n        const { sliderWidth, sliderHeight, itemWidth, itemHeight, vertical, activeSlideAlignment } = this.props;\n\n        if (activeSlideAlignment === 'start') {\n            return vertical ? itemHeight / 2 : itemWidth / 2;\n        } else if (activeSlideAlignment === 'end') {\n            return vertical ?\n                sliderHeight - (itemHeight / 2) :\n                sliderWidth - (itemWidth / 2);\n        } else {\n            return vertical ? sliderHeight / 2 : sliderWidth / 2;\n        }\n    }\n\n    _getCenter (offset) {\n        return offset + this._getViewportOffset() - this._getContainerInnerMargin();\n    }\n\n    _getActiveItem (offset) {\n        const { activeSlideOffset, swipeThreshold } = this.props;\n        const center = this._getCenter(offset);\n        const centerOffset = activeSlideOffset || swipeThreshold;\n\n        for (let i = 0; i < this._positions.length; i++) {\n            const { start, end } = this._positions[i];\n            if (center + centerOffset >= start && center - centerOffset <= end) {\n                return i;\n            }\n        }\n\n        const lastIndex = this._positions.length - 1;\n        if (this._positions[lastIndex] && center - centerOffset > this._positions[lastIndex].end) {\n            return lastIndex;\n        }\n\n        return 0;\n    }\n\n    _initPositionsAndInterpolators (props = this.props) {\n        const { data, itemWidth, itemHeight, scrollInterpolator, vertical } = props;\n        const sizeRef = vertical ? itemHeight : itemWidth;\n\n        if (!data || !data.length) {\n            return;\n        }\n\n        let interpolators = [];\n        this._positions = [];\n\n        this._getCustomData(props).forEach((itemData, index) => {\n            const _index = this._getCustomIndex(index, props);\n            let animatedValue;\n\n            this._positions[index] = {\n                start: index * sizeRef,\n                end: index * sizeRef + sizeRef\n            };\n\n            if (!this._shouldAnimateSlides(props)) {\n                animatedValue = new Animated.Value(1);\n            } else if (this._shouldUseCustomAnimation()) {\n                animatedValue = new Animated.Value(_index === this._activeItem ? 1 : 0);\n            } else {\n                let interpolator;\n\n                if (scrollInterpolator) {\n                    interpolator = scrollInterpolator(_index, props);\n                } else if (this._shouldUseStackLayout()) {\n                    interpolator = stackScrollInterpolator(_index, props);\n                } else if (this._shouldUseTinderLayout()) {\n                    interpolator = tinderScrollInterpolator(_index, props);\n                }\n\n                if (!interpolator || !interpolator.inputRange || !interpolator.outputRange) {\n                    interpolator = defaultScrollInterpolator(_index, props);\n                }\n\n                animatedValue = this._scrollPos.interpolate({\n                    ...interpolator,\n                    extrapolate: 'clamp'\n                });\n            }\n\n            interpolators.push(animatedValue);\n        });\n\n        this.setState({ interpolators });\n    }\n\n    _getSlideAnimation (index, toValue) {\n        const { interpolators } = this.state;\n        const { activeAnimationType, activeAnimationOptions } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animationCommonOptions = {\n            isInteraction: false,\n            useNativeDriver: true,\n            ...activeAnimationOptions,\n            toValue: toValue\n        };\n\n        return Animated.parallel([\n            Animated['timing'](\n                animatedValue,\n                { ...animationCommonOptions, easing: Easing.linear }\n            ),\n            Animated[activeAnimationType](\n                animatedValue,\n                { ...animationCommonOptions }\n            )\n        ]);\n    }\n\n    _playCustomSlideAnimation (current, next) {\n        const { interpolators } = this.state;\n        const itemsLength = this._getCustomDataLength();\n        const _currentIndex = this._getCustomIndex(current);\n        const _currentDataIndex = this._getDataIndex(_currentIndex);\n        const _nextIndex = this._getCustomIndex(next);\n        const _nextDataIndex = this._getDataIndex(_nextIndex);\n        let animations = [];\n\n        // Keep animations in sync when looping\n        if (this._enableLoop()) {\n            for (let i = 0; i < itemsLength; i++) {\n                if (this._getDataIndex(i) === _currentDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 0));\n                } else if (this._getDataIndex(i) === _nextDataIndex && interpolators[i]) {\n                    animations.push(this._getSlideAnimation(i, 1));\n                }\n            }\n        } else {\n            if (interpolators[current]) {\n                animations.push(this._getSlideAnimation(current, 0));\n            }\n            if (interpolators[next]) {\n                animations.push(this._getSlideAnimation(next, 1));\n            }\n        }\n\n        Animated.parallel(animations, { stopTogether: false }).start();\n    }\n\n    _hackActiveSlideAnimation (index, goTo, force = false) {\n        const { data } = this.props;\n\n        if (!this._mounted || !this._carouselRef || !this._positions[index] || (!force && this._enableLoop())) {\n            return;\n        }\n\n        const offset = this._positions[index] && this._positions[index].start;\n\n        if (!offset && offset !== 0) {\n            return;\n        }\n\n        const itemsLength = data && data.length;\n        const direction = goTo || itemsLength === 1 ? 'start' : 'end';\n\n        this._scrollTo(offset + (direction === 'start' ? -1 : 1), false);\n\n        clearTimeout(this._hackSlideAnimationTimeout);\n        this._hackSlideAnimationTimeout = setTimeout(() => {\n            this._scrollTo(offset, false);\n        }, 50); // works randomly when set to '0'\n    }\n\n    _lockScroll () {\n        const { lockScrollTimeoutDuration } = this.props;\n        clearTimeout(this._lockScrollTimeout);\n        this._lockScrollTimeout = setTimeout(() => {\n            this._releaseScroll();\n        }, lockScrollTimeoutDuration);\n        this._setScrollEnabled(false);\n    }\n\n    _releaseScroll () {\n        clearTimeout(this._lockScrollTimeout);\n        this._setScrollEnabled(true);\n    }\n\n    _repositionScroll (index) {\n        const { data, loopClonesPerSide } = this.props;\n        const dataLength = data && data.length;\n\n        if (!this._enableLoop() || !dataLength ||\n            (index >= loopClonesPerSide && index < dataLength + loopClonesPerSide)) {\n            return;\n        }\n\n        let repositionTo = index;\n\n        if (index >= dataLength + loopClonesPerSide) {\n            repositionTo = index - dataLength;\n        } else if (index < loopClonesPerSide) {\n            repositionTo = index + dataLength;\n        }\n\n        this._snapToItem(repositionTo, false, false, false, false);\n    }\n\n    _scrollTo (offset, animated = true) {\n        const { vertical } = this.props;\n        const wrappedRef = this._getWrappedRef();\n\n        if (!this._mounted || !wrappedRef) {\n            return;\n        }\n\n        const specificOptions = this._needsScrollView() ? {\n            x: vertical ? 0 : offset,\n            y: vertical ? offset : 0\n        } : {\n            offset\n        };\n        const options = {\n            ...specificOptions,\n            animated\n        };\n\n        if (this._needsScrollView()) {\n            wrappedRef.scrollTo(options);\n        } else {\n            wrappedRef.scrollToOffset(options);\n        }\n    }\n\n    _onScroll (event) {\n        const { callbackOffsetMargin, enableMomentum, onScroll } = this.props;\n\n        const scrollOffset = event ? this._getScrollOffset(event) : this._currentContentOffset;\n        const nextActiveItem = this._getActiveItem(scrollOffset);\n        const itemReached = nextActiveItem === this._itemToSnapTo;\n        const scrollConditions =\n            scrollOffset >= this._scrollOffsetRef - callbackOffsetMargin &&\n            scrollOffset <= this._scrollOffsetRef + callbackOffsetMargin;\n\n        this._currentContentOffset = scrollOffset;\n        this._onScrollTriggered = true;\n        this._lastScrollDate = Date.now();\n\n        if (this._activeItem !== nextActiveItem && this._shouldUseCustomAnimation()) {\n            this._playCustomSlideAnimation(this._activeItem, nextActiveItem);\n        }\n\n        if (enableMomentum) {\n            clearTimeout(this._snapNoMomentumTimeout);\n\n            if (this._activeItem !== nextActiveItem) {\n                this._activeItem = nextActiveItem;\n            }\n\n            if (itemReached) {\n                if (this._canFireBeforeCallback) {\n                    this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n                }\n\n                if (scrollConditions && this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        } else if (this._activeItem !== nextActiveItem && itemReached) {\n            if (this._canFireBeforeCallback) {\n                this._onBeforeSnap(this._getDataIndex(nextActiveItem));\n            }\n\n            if (scrollConditions) {\n                this._activeItem = nextActiveItem;\n\n                if (this._canLockScroll()) {\n                    this._releaseScroll();\n                }\n\n                if (this._canFireCallback) {\n                    this._onSnap(this._getDataIndex(nextActiveItem));\n                }\n            }\n        }\n\n        if (nextActiveItem === this._itemToSnapTo &&\n            scrollOffset === this._scrollOffsetRef) {\n            this._repositionScroll(nextActiveItem);\n        }\n\n        if (typeof onScroll === \"function\" && event) {\n            onScroll(event);\n        }\n    }\n\n    _onStartShouldSetResponderCapture (event) {\n        const { onStartShouldSetResponderCapture } = this.props;\n\n        if (onStartShouldSetResponderCapture) {\n            onStartShouldSetResponderCapture(event);\n        }\n\n        return this._getScrollEnabled();\n    }\n\n    _onTouchStart () {\n        const { onTouchStart } = this.props\n\n        // `onTouchStart` is fired even when `scrollEnabled` is set to `false`\n        if (this._getScrollEnabled() !== false && this._autoplaying) {\n            this.pauseAutoPlay();\n        }\n\n        if (onTouchStart) {\n            onTouchStart()\n        }\n    }\n\n    _onTouchEnd () {\n        const { onTouchEnd } = this.props\n\n        if (this._getScrollEnabled() !== false && this._autoplay && !this._autoplaying) {\n            // This event is buggy on Android, so a fallback is provided in _onScrollEnd()\n            this.startAutoplay();\n        }\n\n        if (onTouchEnd) {\n            onTouchEnd()\n        }\n    }\n\n    // Used when `enableSnap` is ENABLED\n    _onScrollBeginDrag (event) {\n        const { onScrollBeginDrag } = this.props;\n\n        if (!this._getScrollEnabled()) {\n            return;\n        }\n\n        this._scrollStartOffset = this._getScrollOffset(event);\n        this._scrollStartActive = this._getActiveItem(this._scrollStartOffset);\n        this._ignoreNextMomentum = false;\n        // this._canFireCallback = false;\n\n        if (onScrollBeginDrag) {\n            onScrollBeginDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is DISABLED\n    _onScrollEndDrag (event) {\n        const { onScrollEndDrag } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onScrollEndDrag) {\n            onScrollEndDrag(event);\n        }\n    }\n\n    // Used when `enableMomentum` is ENABLED\n    _onMomentumScrollEnd (event) {\n        const { onMomentumScrollEnd } = this.props;\n\n        if (this._carouselRef) {\n            this._onScrollEnd && this._onScrollEnd();\n        }\n\n        if (onMomentumScrollEnd) {\n            onMomentumScrollEnd(event);\n        }\n    }\n\n    _onScrollEnd (event) {\n        const { autoplayDelay, enableSnap } = this.props;\n\n        if (this._ignoreNextMomentum) {\n            // iOS fix\n            this._ignoreNextMomentum = false;\n            return;\n        }\n\n        if (this._currentContentOffset === this._scrollEndOffset) {\n            return;\n        }\n\n        this._scrollEndOffset = this._currentContentOffset;\n        this._scrollEndActive = this._getActiveItem(this._scrollEndOffset);\n\n        if (enableSnap) {\n            this._snapScroll(this._scrollEndOffset - this._scrollStartOffset);\n        }\n\n        // The touchEnd event is buggy on Android, so this will serve as a fallback whenever needed\n        // https://github.com/facebook/react-native/issues/9439\n        if (this._autoplay && !this._autoplaying) {\n            clearTimeout(this._enableAutoplayTimeout);\n            this._enableAutoplayTimeout = setTimeout(() => {\n                this.startAutoplay();\n            }, autoplayDelay + 50);\n        }\n    }\n\n    // Due to a bug, this event is only fired on iOS\n    // https://github.com/facebook/react-native/issues/6791\n    // it's fine since we're only fixing an iOS bug in it, so ...\n    _onTouchRelease (event) {\n        const { enableMomentum } = this.props;\n\n        if (enableMomentum && IS_IOS) {\n            clearTimeout(this._snapNoMomentumTimeout);\n            this._snapNoMomentumTimeout = setTimeout(() => {\n                this._snapToItem(this._activeItem);\n            }, 100);\n        }\n    }\n\n    _onLayout (event) {\n        const { onLayout } = this.props;\n\n        // Prevent unneeded actions during the first 'onLayout' (triggered on init)\n        if (this._onLayoutInitDone) {\n            this._initPositionsAndInterpolators();\n            this._snapToItem(this._activeItem, false, false, false, false);\n        } else {\n            this._onLayoutInitDone = true;\n        }\n\n        if (onLayout) {\n            onLayout(event);\n        }\n    }\n\n    _snapScroll (delta) {\n        const { swipeThreshold } = this.props;\n\n        // When using momentum and releasing the touch with\n        // no velocity, scrollEndActive will be undefined (iOS)\n        if (!this._scrollEndActive && this._scrollEndActive !== 0 && IS_IOS) {\n            this._scrollEndActive = this._scrollStartActive;\n        }\n\n        if (this._scrollStartActive !== this._scrollEndActive) {\n            // Snap to the new active item\n            this._snapToItem(this._scrollEndActive);\n        } else {\n            // Snap depending on delta\n            if (delta > 0) {\n                if (delta > swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive + 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else if (delta < 0) {\n                if (delta < -swipeThreshold) {\n                    this._snapToItem(this._scrollStartActive - 1);\n                } else {\n                    this._snapToItem(this._scrollEndActive);\n                }\n            } else {\n                // Snap to current\n                this._snapToItem(this._scrollEndActive);\n            }\n        }\n    }\n\n    _snapToItem (index, animated = true, fireCallback = true, initial = false, lockScroll = true) {\n        const { enableMomentum, onSnapToItem, onBeforeSnapToItem } = this.props;\n        const itemsLength = this._getCustomDataLength();\n        const wrappedRef = this._getWrappedRef();\n\n        if (!itemsLength || !wrappedRef) {\n            return;\n        }\n\n        if (!index || index < 0) {\n            index = 0;\n        } else if (itemsLength > 0 && index >= itemsLength) {\n            index = itemsLength - 1;\n        }\n\n        if (index !== this._previousActiveItem) {\n            this._previousActiveItem = index;\n\n            // Placed here to allow overscrolling for edges items\n            if (lockScroll && this._canLockScroll()) {\n                this._lockScroll();\n            }\n\n            if (fireCallback) {\n                if (onBeforeSnapToItem) {\n                    this._canFireBeforeCallback = true;\n                }\n\n                if (onSnapToItem) {\n                    this._canFireCallback = true;\n                }\n            }\n        }\n\n        this._itemToSnapTo = index;\n        this._scrollOffsetRef = this._positions[index] && this._positions[index].start;\n        this._onScrollTriggered = false;\n\n        if (!this._scrollOffsetRef && this._scrollOffsetRef !== 0) {\n            return;\n        }\n\n        this._scrollTo(this._scrollOffsetRef, animated);\n\n        this._scrollEndOffset = this._currentContentOffset;\n\n        if (enableMomentum) {\n            // iOS fix, check the note in the constructor\n            if (!initial) {\n                this._ignoreNextMomentum = true;\n            }\n\n            // When momentum is enabled and the user is overscrolling or swiping very quickly,\n            // 'onScroll' is not going to be triggered for edge items. Then callback won't be\n            // fired and loop won't work since the scrollview is not going to be repositioned.\n            // As a workaround, '_onScroll()' will be called manually for these items if a given\n            // condition hasn't been met after a small delay.\n            // WARNING: this is ok only when relying on 'momentumScrollEnd', not with 'scrollEndDrag'\n            if (index === 0 || index === itemsLength - 1) {\n                clearTimeout(this._edgeItemTimeout);\n                this._edgeItemTimeout = setTimeout(() => {\n                    if (!initial && index === this._activeItem && !this._onScrollTriggered) {\n                        this._onScroll();\n                    }\n                }, 250);\n            }\n        }\n    }\n\n    _onBeforeSnap (index) {\n        const { onBeforeSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireBeforeCallback = false;\n        onBeforeSnapToItem && onBeforeSnapToItem(index);\n    }\n\n    _onSnap (index) {\n        const { onSnapToItem } = this.props;\n\n        if (!this._carouselRef) {\n            return;\n        }\n\n        this._canFireCallback = false;\n        onSnapToItem && onSnapToItem(index);\n    }\n\n    startAutoplay () {\n        const { autoplayInterval, autoplayDelay } = this.props;\n        this._autoplay = true;\n\n        if (this._autoplaying) {\n            return;\n        }\n\n        clearTimeout(this._autoplayTimeout);\n        this._autoplayTimeout = setTimeout(() => {\n            this._autoplaying = true;\n            this._autoplayInterval = setInterval(() => {\n                if (this._autoplaying) {\n                    this.snapToNext();\n                }\n            }, autoplayInterval);\n        }, autoplayDelay);\n    }\n\n    pauseAutoPlay () {\n        this._autoplaying = false;\n        clearTimeout(this._autoplayTimeout);\n        clearTimeout(this._enableAutoplayTimeout);\n        clearInterval(this._autoplayInterval);\n    }\n\n    stopAutoplay () {\n        this._autoplay = false;\n        this.pauseAutoPlay();\n    }\n\n    snapToItem (index, animated = true, fireCallback = true) {\n        if (!index || index < 0) {\n            index = 0;\n        }\n\n        const positionIndex = this._getPositionIndex(index);\n\n        if (positionIndex === this._activeItem) {\n            return;\n        }\n\n        this._snapToItem(positionIndex, animated, fireCallback);\n    }\n\n    snapToNext (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem + 1;\n        if (newIndex > itemsLength - 1) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = 0;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    snapToPrev (animated = true, fireCallback = true) {\n        const itemsLength = this._getCustomDataLength();\n\n        let newIndex = this._activeItem - 1;\n        if (newIndex < 0) {\n            if (!this._enableLoop()) {\n                return;\n            }\n            newIndex = itemsLength - 1;\n        }\n        this._snapToItem(newIndex, animated, fireCallback);\n    }\n\n    // https://github.com/facebook/react-native/issues/1831#issuecomment-231069668\n    triggerRenderingHack (offset) {\n        // Avoid messing with user scroll\n        if (Date.now() - this._lastScrollDate < 500) {\n            return;\n        }\n\n        const scrollPosition = this._currentContentOffset;\n        if (!scrollPosition && scrollPosition !== 0) {\n            return;\n        }\n\n        const scrollOffset = offset || (scrollPosition === 0 ? 1 : -1);\n        this._scrollTo(scrollPosition + scrollOffset, false);\n    }\n\n    _getSlideInterpolatedStyle (index, animatedValue) {\n        const { layoutCardOffset, slideInterpolatedStyle } = this.props;\n\n        if (slideInterpolatedStyle) {\n            return slideInterpolatedStyle(index, animatedValue, this.props);\n        } else if (this._shouldUseTinderLayout()) {\n            return tinderAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseStackLayout()) {\n            return stackAnimatedStyles(index, animatedValue, this.props, layoutCardOffset);\n        } else if (this._shouldUseShiftLayout()) {\n            return shiftAnimatedStyles(index, animatedValue, this.props);\n        } else {\n            return defaultAnimatedStyles(index, animatedValue, this.props);\n        }\n    }\n\n    _renderItem ({ item, index }) {\n        const { interpolators } = this.state;\n        const {\n            hasParallaxImages,\n            itemWidth,\n            itemHeight,\n            keyExtractor,\n            renderItem,\n            sliderHeight,\n            sliderWidth,\n            slideStyle,\n            vertical\n        } = this.props;\n\n        const animatedValue = interpolators && interpolators[index];\n\n        if (!animatedValue && animatedValue !== 0) {\n            return null;\n        }\n\n        const animate = this._shouldAnimateSlides();\n        const Component = animate ? Animated.View : View;\n        const animatedStyle = animate ? this._getSlideInterpolatedStyle(index, animatedValue) : {};\n\n        const parallaxProps = hasParallaxImages ? {\n            scrollPosition: this._scrollPos,\n            carouselRef: this._carouselRef,\n            vertical,\n            sliderWidth,\n            sliderHeight,\n            itemWidth,\n            itemHeight\n        } : undefined;\n\n        const mainDimension = vertical ? { height: itemHeight } : { width: itemWidth };\n        const specificProps = this._needsScrollView() ? {\n            key: keyExtractor ? keyExtractor(item, index) : this._getKeyExtractor(item, index)\n        } : {};\n\n        return (\n            <Component style={[mainDimension, slideStyle, animatedStyle]} pointerEvents={'box-none'} {...specificProps}>\n                { renderItem({ item, index }, parallaxProps) }\n            </Component>\n        );\n    }\n\n    _getComponentOverridableProps () {\n        const {\n            enableMomentum,\n            itemWidth,\n            itemHeight,\n            loopClonesPerSide,\n            sliderWidth,\n            sliderHeight,\n            vertical\n        } = this.props;\n\n        const visibleItems = Math.ceil(vertical ?\n            sliderHeight / itemHeight :\n            sliderWidth / itemWidth) + 1;\n        const initialNumPerSide = this._enableLoop() ? loopClonesPerSide : 2;\n        const initialNumToRender = visibleItems + (initialNumPerSide * 2);\n        const maxToRenderPerBatch = 1 + (initialNumToRender * 2);\n        const windowSize = maxToRenderPerBatch;\n\n        const specificProps = !this._needsScrollView() ? {\n            initialNumToRender: initialNumToRender,\n            maxToRenderPerBatch: maxToRenderPerBatch,\n            windowSize: windowSize\n            // updateCellsBatchingPeriod\n        } : {};\n\n        return {\n            decelerationRate: enableMomentum ? 0.9 : 'fast',\n            showsHorizontalScrollIndicator: false,\n            showsVerticalScrollIndicator: false,\n            overScrollMode: 'never',\n            automaticallyAdjustContentInsets: false,\n            directionalLockEnabled: true,\n            pinchGestureEnabled: false,\n            scrollsToTop: false,\n            removeClippedSubviews: !this._needsScrollView(),\n            inverted: this._needsRTLAdaptations(),\n            // renderToHardwareTextureAndroid: true,\n            ...specificProps\n        };\n    }\n\n    _getComponentStaticProps () {\n        const { hideCarousel } = this.state;\n        const {\n            containerCustomStyle,\n            contentContainerCustomStyle,\n            keyExtractor,\n            sliderWidth,\n            sliderHeight,\n            style,\n            vertical\n        } = this.props;\n\n        const containerStyle = [\n            containerCustomStyle || style || {},\n            hideCarousel ? { opacity: 0 } : {},\n            vertical ?\n                { height: sliderHeight, flexDirection: 'column' } :\n                // LTR hack; see https://github.com/facebook/react-native/issues/11960\n                // and https://github.com/facebook/react-native/issues/13100#issuecomment-328986423\n                { width: sliderWidth, flexDirection: this._needsRTLAdaptations() ? 'row-reverse' : 'row' }\n        ];\n        const contentContainerStyle = [\n            vertical ? {\n                paddingTop: this._getContainerInnerMargin(),\n                paddingBottom: this._getContainerInnerMargin(true)\n            } : {\n                paddingLeft: this._getContainerInnerMargin(),\n                paddingRight: this._getContainerInnerMargin(true)\n            },\n            contentContainerCustomStyle || {}\n        ];\n\n        const specificProps = !this._needsScrollView() ? {\n            // extraData: this.state,\n            renderItem: this._renderItem,\n            numColumns: 1,\n            keyExtractor: keyExtractor || this._getKeyExtractor\n        } : {};\n\n        return {\n            ref: c => this._carouselRef = c,\n            data: this._getCustomData(),\n            style: containerStyle,\n            contentContainerStyle: contentContainerStyle,\n            horizontal: !vertical,\n            scrollEventThrottle: 1,\n            onScroll: this._onScrollHandler,\n            onScrollBeginDrag: this._onScrollBeginDrag,\n            onScrollEndDrag: this._onScrollEndDrag,\n            onMomentumScrollEnd: this._onMomentumScrollEnd,\n            onResponderRelease: this._onTouchRelease,\n            onStartShouldSetResponderCapture: this._onStartShouldSetResponderCapture,\n            onTouchStart: this._onTouchStart,\n            onTouchEnd: this._onScrollEnd,\n            onLayout: this._onLayout,\n            ...specificProps\n        };\n    }\n\n    render () {\n        const { data, renderItem, useScrollView } = this.props;\n\n        if (!data || !renderItem) {\n            return null;\n        }\n\n        const props = {\n            ...this._getComponentOverridableProps(),\n            ...this.props,\n            ...this._getComponentStaticProps()\n        };\n\n        const ScrollViewComponent = typeof useScrollView === 'function' ? useScrollView : AnimatedScrollView\n\n        return this._needsScrollView() ? (\n            <ScrollViewComponent {...props}>\n                {\n                    this._getCustomData().map((item, index) => {\n                        return this._renderItem({ item, index });\n                    })\n                }\n            </ScrollViewComponent>\n        ) : (\n            <AnimatedFlatList {...props} />\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}